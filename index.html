<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V30 çµ‚æ¥µæŒ‡å®šç‰ˆ</title>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvScriptLoad()" type="text/javascript"></script>
    
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #121212; color: #e0e0e0; margin: 0; padding: 20px; height: 100vh; box-sizing: border-box; overflow: hidden; }
        h2 { color: #fff; margin: 0 0 5px 0; font-size: 1.5rem; }
        .subtitle { color: #888; font-size: 0.9em; margin-bottom: 15px; }
        
        button { background: #333; color: white; border: 1px solid #555; padding: 10px 15px; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s; user-select: none;}
        button:hover:not(:disabled) { background: #444; border-color: #777; }
        button:active:not(:disabled) { transform: translateY(1px); }
        button.primary { background: #007bff; border-color: #007bff; font-weight: bold;}
        button.primary:hover:not(:disabled) { background: #0056b3; }
        button.success { background: #28a745; border-color: #28a745; font-weight: bold;}
        button.success:hover:not(:disabled) { background: #218838; }
        button.warning { background: #ff9800; border-color: #f57c00; color: #000; font-weight: bold;} 
        button.warning:hover:not(:disabled) { background: #fb8c00; }
        
        button:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(1); }
        #status { font-family: monospace; color: #aaa; margin-top: 10px; min-height: 1.2em; font-size: 0.85em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        
        .main-layout { display: flex; gap: 20px; height: calc(100% - 70px); align-items: flex-start; }
        
        .left-panel { 
            flex: 0 0 320px; background: #1e1e1e; padding: 20px; border-radius: 8px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px; 
            height: 100%; overflow-y: auto; box-sizing: border-box; border: 1px solid #333;
        }
        .step-box { border: 1px solid #444; padding: 15px; border-radius: 6px; background: #252525; transition: all 0.3s;}
        .step-box.active { border-color: #007bff; background: #2c3e50; }
        .step-box.done { border-color: #28a745; opacity: 0.7; }
        .step-title { font-weight: bold; margin-bottom: 10px; display: block; color: #fff; font-size: 0.9rem; border-bottom: 1px solid #444; padding-bottom: 5px;}
        
        .upload-zone { 
            border: 2px dashed #555; padding: 25px 10px; text-align: center; border-radius: 6px; 
            cursor: pointer; transition: all 0.2s; background: rgba(255,255,255,0.02); color: #aaa; font-size: 0.9em;
            pointer-events: none; opacity: 0.5;
        }
        .upload-zone.ready { pointer-events: auto; opacity: 1; border-color: #007bff; color: #eee; }
        .upload-zone:hover { background: rgba(0,123,255,0.05); }

        .right-panel { flex: 1; display: flex; gap: 20px; height: 100%; min-width: 0; }
        .canvas-wrapper { 
            flex: 1; background: #000; padding: 2px; border-radius: 4px; border: 1px solid #333;
            display: flex; flex-direction: column; position: relative; min-width: 0; overflow: hidden;
        }
        .canvas-header { 
            background: #1e1e1e; padding: 8px 12px; font-weight: bold; font-size: 0.85rem; 
            display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; z-index: 5;
        }
        
        .viewport {
            flex: 1; background: #111; overflow: hidden; position: relative; cursor: grab;
            background-image: radial-gradient(#222 1px, transparent 1px); background-size: 20px 20px;
        }
        .viewport.grabbing { cursor: grabbing; }
        .viewport.crosshair { cursor: crosshair; }

        #transformLayer { transform-origin: 0 0; position: absolute; top: 0; left: 0; will-change: transform; }
        .relative-img-wrap { position: relative; line-height: 0; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        canvas { display: block; }

        #maskOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.6; z-index: 2; }
        #manualAdjustLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; display: none; }
        #highlightPolygon { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; opacity: 0; transition: opacity 0.3s; }
        #highlightPolygon polygon { fill: rgba(0, 255, 0, 0.1); stroke: #00ff00; stroke-width: 2; vector-effect: non-scaling-stroke; }
        #tempSelectionBox { position: absolute; border: 1px dashed #ff0055; background: rgba(255, 0, 85, 0.1); pointer-events: none; display: none; z-index: 20; }
        
        .corner-point {
            position: absolute; width: 16px; height: 16px; 
            background: rgba(255, 50, 50, 0.8); border: 2px solid #fff; border-radius: 50%;
            transform: translate(-50%, -50%); cursor: grab; pointer-events: auto; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.8); z-index: 30; transition: transform 0.1s, background 0.1s;
        }
        .corner-point:hover { background: #ff0000; z-index: 40; border-color: #ffff00; transform: translate(-50%, -50%) scale(1.3);}
        
        .zoom-controls { position: absolute; bottom: 15px; right: 15px; display: flex; gap: 5px; z-index: 50; }
        .zoom-btn { background: rgba(0,0,0,0.7); color: white; border: 1px solid #555; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer; font-size: 16px; }
        .zoom-btn:hover { background: rgba(0,0,0,0.9); border-color: #888; }
        #canvasOutput { width: 100%; height: 100%; object-fit: contain; background: #000; }
        .btn-group { display: flex; gap: 8px; }
        .btn-group button { flex: 1; }
        
        .ai-toggle-container { margin-top: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; border: 1px solid #444; }
        .ai-options { display: flex; flex-direction: column; gap: 8px; margin-top: 5px;}
        select { background: #333; color: white; padding: 5px; border: 1px solid #555; border-radius: 4px; width: 100%; }

        #progressBarContainer { display:none; margin-top: 10px; background: #333; border-radius: 4px; height: 6px; overflow: hidden; }
        #progressBar { width: 0%; height: 100%; background: #00bcd4; transition: width 0.3s; }
        #progressText { font-size: 0.8em; color: #00bcd4; margin-top: 5px; display:none; white-space: pre-wrap;}

    </style>
</head>
<body>

<div style="text-align: center;">
    <h2>ğŸªª V30 çµ‚æ¥µæŒ‡å®šç‰ˆ</h2>
    <p class="subtitle">æ‰‹å‹•æŒ‡å®šæª”å | æš´åŠ›æ¸…é™¤å¿«å–</p>
</div>

<div class="main-layout">
    <div class="left-panel">
        <div id="step1" class="step-box active">
            <span class="step-title">1. ä¸Šå‚³ç…§ç‰‡</span>
            <div id="systemLoading" style="text-align:center; color:#ffd700; margin-bottom:10px; font-size:0.85em;">
                â³ æ­£åœ¨åˆå§‹åŒ–å½±åƒå¼•æ“...
            </div>
            <input type="file" id="fileInput" accept="image/*" style="display:none">
            <div class="upload-zone" onclick="document.getElementById('fileInput').click()" id="uploadBox">
                <span id="uploadText">ğŸ“· è«‹ç¨å€™...</span>
            </div>
        </div>

        <div id="step2" class="step-box" style="pointer-events: none; opacity: 0.5; flex: 1; display:flex; flex-direction:column;">
            <span class="step-title">2. ç·¨è¼¯èˆ‡è¼¸å‡º</span>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <div class="btn-group">
                    <button onclick="rotateSource(-90)" class="info" title="å‘å·¦æ—‹è½‰">â†º å·¦è½‰</button>
                    <button onclick="rotateSource(90)" class="info" title="å‘å³æ—‹è½‰">â†» å³è½‰</button>
                </div>

                <div class="ai-toggle-container">
                    <span style="font-size: 0.9em; font-weight: bold;">ğŸ¤– AI è¨­å®š</span>
                    <div class="ai-options">
                        <label style="font-size: 0.8em; color: #aaa;">GitHub ä¸Šçš„æ¨¡å‹æª”åï¼š</label>
                        <select id="modelFilename">
                            <option value="model.onnx">model.onnx</option>
                            <option value="model_quantized.onnx">model_quantized.onnx</option>
                        </select>
                        <button onclick="window.initAI()" class="primary" id="loadAiBtn" style="width:100%; margin-top:5px;">ğŸš€ è¼‰å…¥æ¨¡å‹</button>
                    </div>
                </div>
                
                <div id="progressBarContainer"><div id="progressBar"></div></div>
                <div id="progressText"></div>

                <div class="btn-group">
                    <button onclick="autoDetect()" id="autoBtn" class="primary" disabled>âš¡ AI åµæ¸¬</button>
                    <button onclick="toggleDrawMode()" id="drawBtn" class="warning" disabled>ğŸ–ï¸ æ‰‹å‹•ç•«æ¡†</button>
                </div>

                <button onclick="resetView()" class="zoom-reset" style="font-size: 12px; padding: 5px;">ğŸ” é‡ç½®è¦–è§’ (Fit Screen)</button>
                
                <div id="manualControls" style="display:block; border-top: 1px solid #444; padding-top: 10px; margin-top: 5px;">
                    <p id="guideText" style="font-size:0.85em; color:#ddd; margin: 0 0 8px;">ğŸ‘‡ å¾®èª¿ç´…é»ä½ç½®ï¼š</p>
                    <button onclick="applyManualCrop()" id="applyBtn" class="success" style="width:100%">âœ… æ‡‰ç”¨è£åˆ‡</button>
                </div>
                
                <div style="margin-top: auto;">
                    <button onclick="downloadResult()" id="dlBtn" disabled style="width:100%">ğŸ“¥ ä¸‹è¼‰çµæœ</button>
                </div>
            </div>
            <div id="status"></div>
        </div>
    </div>

    <div class="right-panel">
        <div class="canvas-wrapper">
            <div class="canvas-header">
                <span>ğŸ“ åŸå§‹å½±åƒ (ç´…è‰² = AI è¾¨è­˜å€åŸŸ)</span>
                <small id="modeIndicator" style="color:#aaa;">æ»¾è¼ªç¸®æ”¾ / æ‹–æ›³èƒŒæ™¯ç§»å‹•</small>
            </div>
            <div class="viewport" id="viewport">
                <div id="transformLayer">
                    <div class="relative-img-wrap" id="imgWrap">
                        <canvas id="canvasInput"></canvas>
                        <canvas id="maskOverlay"></canvas>
                        <svg id="highlightPolygon"><polygon points=""></polygon></svg>
                        <div id="tempSelectionBox"></div>
                        <div id="manualAdjustLayer">
                            <div class="corner-point" id="cp-tl"></div>
                            <div class="corner-point" id="cp-tr"></div>
                            <div class="corner-point" id="cp-br"></div>
                            <div class="corner-point" id="cp-bl"></div>
                        </div>
                    </div>
                </div>
                <div class="zoom-controls">
                    <div class="zoom-btn" onclick="zoomIn()">+</div>
                    <div class="zoom-btn" onclick="zoomOut()">-</div>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper" style="flex: 0 0 35%;">
            <div class="canvas-header">âœ‚ï¸ è£åˆ‡çµæœ</div>
            <div style="flex:1; background:#000; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                <canvas id="canvasOutput"></canvas>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.1'; 
    
    // V30 è¨­å®š: å…è¨±é ç«¯é€£ç·š (å› ç‚º GitHub Pages ç®—é ç«¯)
    env.allowLocalModels = false; 
    env.allowRemoteModels = true; 
    env.useBrowserCache = false; // ç¦æ­¢å¿«å–
    env.backends.onnx.wasm.numThreads = 1;

    let segmenter = null;

    // å·¥å…·ï¼šå–å¾—ç›®å‰ç¶²é çš„æ ¹ç›®éŒ„
    function getModelPath() {
        let path = window.location.href;
        if (path.endsWith('index.html')) {
            path = path.substring(0, path.length - 'index.html'.length);
        }
        if (!path.endsWith('/')) path += '/';
        return path + 'model/';
    }

    window.initAI = async function() {
        const pBar = document.getElementById('progressBar');
        const pCon = document.getElementById('progressBarContainer');
        const pTxt = document.getElementById('progressText');
        const loadBtn = document.getElementById('loadAiBtn');
        const modelPath = getModelPath();
        
        // å–å¾—ä½¿ç”¨è€…é¸çš„æª”å
        const selectedFilename = document.getElementById('modelFilename').value;
        const isQuantized = selectedFilename.includes('quantized');

        loadBtn.disabled = true;
        pCon.style.display = 'block';
        pTxt.style.display = 'block';
        pTxt.innerText = `ğŸ” å˜—è©¦è®€å– ${selectedFilename} ...\nè·¯å¾‘: ${modelPath}`;

        try {
            // éš¨æ©Ÿæ•¸ç ´é™¤å¿«å–
            const cacheBuster = "?t=" + new Date().getTime(); 
            
            // æ‰‹å‹• fetch æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å­˜åœ¨
            const checkRes = await fetch(modelPath + selectedFilename + cacheBuster, { method: 'HEAD' });
            if(!checkRes.ok) {
                throw new Error(`æ‰¾ä¸åˆ°æª”æ¡ˆ ${selectedFilename} (HTTP ${checkRes.status})`);
            }

            pTxt.innerText = "âœ… æª”æ¡ˆå­˜åœ¨ï¼Œé–‹å§‹è¼‰å…¥å¼•æ“...";

            // å»ºç«‹ pipeline
            segmenter = await pipeline('image-segmentation', modelPath, {
                quantized: isQuantized, // é—œéµï¼šæ ¹æ“šæª”åæ±ºå®šæ˜¯å¦é–‹å•Ÿé‡åŒ–æ¨¡å¼
                progress_callback: (data) => {
                    if (data.status === 'progress') {
                        const percent = Math.round(data.progress * 100);
                        pBar.style.width = percent + "%";
                        pTxt.innerText = `ğŸ“¥ è¼‰å…¥ä¸­: ${percent}%`;
                    } else if (data.status === 'done') {
                        pTxt.innerText = "âœ… è¼‰å…¥å®Œæˆ";
                    }
                }
            });
            
            pTxt.innerText = "âœ… AI æº–å‚™å°±ç·’ï¼è«‹é»æ“Šã€âš¡ AI åµæ¸¬ã€";
            pTxt.style.color = "#4caf50";
            document.getElementById('autoBtn').disabled = false;
            setTimeout(() => { pCon.style.display = 'none'; }, 2000);
            return true;

        } catch (e) { 
            console.error("AI è¼‰å…¥å¤±æ•—", e); 
            pTxt.innerText = "âŒ å¤±æ•—ï¼š" + e.message + "\nè«‹ç¢ºèª GitHub æª”åæ˜¯å¦èˆ‡é¸å–®ä¸€è‡´ï¼";
            pTxt.style.color = "#ff5252";
            loadBtn.disabled = false;
            return false; 
        }
    };

    window.runAIRemoval = async function(dataUrl, width, height) {
        if (!segmenter) {
            const success = await window.initAI();
            if (!success) throw new Error("AI æ¨¡å‹æœªè¼‰å…¥");
        }
        
        document.getElementById('progressText').style.display = 'block';
        document.getElementById('progressText').innerText = "ğŸ§  AI é‹ç®—ä¸­...";
        
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 60000));
        const processPromise = async () => {
            const output = await segmenter(dataUrl);
            const maskBitmap = await output.mask.toCanvas();
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(maskBitmap, 0, 0, width, height);
            
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const val = data[i]; 
                if (val > 10) { 
                    data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                } else {
                    data[i] = 0; data[i+1] = 0; data[i+2] = 0; data[i+3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };

        try {
            const result = await Promise.race([processPromise(), timeoutPromise]);
            document.getElementById('progressText').style.display = 'none';
            return result;
        } catch (error) {
            document.getElementById('progressText').innerText = "âš ï¸ é‹ç®—éŒ¯èª¤ï¼š" + error.message;
            throw error;
        }
    }
</script>

<script>
    let imgElement = new Image();
    let isCvLoaded = false;
    let currentCorners = { tl: {x:0,y:0}, tr: {x:0,y:0}, br: {x:0,y:0}, bl: {x:0,y:0} };
    let scale = 1, panX = 0, panY = 0, isPanning = false, startPanX = 0, startPanY = 0;
    let isDrawingMode = false, isDrawing = false, drawStartX = 0, drawStartY = 0, activePoint = null;

    const viewport = document.getElementById('viewport');
    const transformLayer = document.getElementById('transformLayer');
    const canvasInput = document.getElementById('canvasInput');
    const maskOverlay = document.getElementById('maskOverlay');
    const canvasOutput = document.getElementById('canvasOutput');
    const ctxInput = canvasInput.getContext('2d');
    const ctxOverlay = maskOverlay.getContext('2d');
    const highlightPolygon = document.getElementById('highlightPolygon');
    const polyShape = highlightPolygon.querySelector('polygon');
    const manualAdjustLayer = document.getElementById('manualAdjustLayer');
    const imgWrap = document.getElementById('imgWrap');
    const tempSelectionBox = document.getElementById('tempSelectionBox');
    const cornerPoints = document.querySelectorAll('.corner-point');
    const statusText = document.getElementById('status');
    const modeIndicator = document.getElementById('modeIndicator');
    const uploadBox = document.getElementById('uploadBox');

    function log(msg, type='') {
        statusText.innerText = msg;
        statusText.style.color = type === 'error' ? '#ff5252' : (type === 'warning' ? '#ffc107' : type === 'success' ? '#4caf50' : '#aaa');
    }

    function onOpenCvScriptLoad() {
        let checkInterval = setInterval(() => {
            if (typeof cv !== 'undefined' && cv.Mat) {
                clearInterval(checkInterval);
                isCvLoaded = true;
                document.getElementById('systemLoading').innerText = "âœ… å½±åƒå¼•æ“å°±ç·’";
                document.getElementById('systemLoading').style.color = "#4caf50";
                uploadBox.classList.add('ready');
                document.getElementById('uploadText').innerText = "ğŸ“· é»æ“Šä¸Šå‚³ / æ‹–æ›³åœ–ç‰‡";
            }
        }, 200);
    }

    document.getElementById('fileInput').addEventListener('change', (e) => handleFile(e.target.files[0]));
    uploadBox.addEventListener('dragover', (e) => { e.preventDefault(); if(isCvLoaded) uploadBox.style.borderColor = '#007bff'; });
    uploadBox.addEventListener('dragleave', (e) => { e.preventDefault(); if(isCvLoaded) uploadBox.style.borderColor = '#555'; });
    uploadBox.addEventListener('drop', (e) => { e.preventDefault(); if(isCvLoaded) { uploadBox.style.borderColor = '#555'; handleFile(e.dataTransfer.files[0]); }});

    function handleFile(file) {
        if(!file) return;
        let url = URL.createObjectURL(file);
        imgElement.src = url;
        imgElement.onload = function() {
            refreshCanvasInput();
            resetCorners();
            highlightPolygon.style.opacity = '0';
            manualAdjustLayer.style.display = 'block';
            ctxOverlay.clearRect(0, 0, maskOverlay.width, maskOverlay.height);
            document.getElementById('step1').classList.remove('active'); document.getElementById('step1').classList.add('done');
            activateStep(document.getElementById('step2'));
            document.getElementById('autoBtn').disabled = true; // å…ˆç¦ç”¨ï¼Œç­‰æŒ‰è¼‰å…¥æ¨¡å‹
            document.getElementById('drawBtn').disabled = false;
            resetView();
            log("ğŸ“· è¼‰å…¥å®Œæˆï¼Œè«‹å…ˆé»æ“Šã€ğŸš€ è¼‰å…¥æ¨¡å‹ã€");
        }
    }

    function activateStep(el) { el.style.pointerEvents = "auto"; el.style.opacity = "1"; el.classList.add('active'); }

    function refreshCanvasInput() {
        canvasInput.width = imgElement.width;
        canvasInput.height = imgElement.height;
        maskOverlay.width = imgElement.width;
        maskOverlay.height = imgElement.height;
        ctxInput.drawImage(imgElement, 0, 0);
    }

    function rotateSource(degrees) {
        if (!imgElement.src) return;
        const tempCanvas = document.createElement('canvas');
        const ctx = tempCanvas.getContext('2d');
        const w = imgElement.width; const h = imgElement.height;
        tempCanvas.width = h; tempCanvas.height = w;
        ctx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        ctx.rotate(degrees * Math.PI / 180);
        ctx.drawImage(imgElement, -w / 2, -h / 2);
        imgElement.src = tempCanvas.toDataURL();
        ctxOverlay.clearRect(0, 0, maskOverlay.width, maskOverlay.height);
    }

    function updateTransform() { transformLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }
    function resetView() {
        const vW = viewport.clientWidth; const vH = viewport.clientHeight;
        const iW = imgElement.width; const iH = imgElement.height;
        scale = Math.min((vW - 40) / iW, (vH - 40) / iH, 1);
        panX = (vW - iW * scale) / 2; panY = (vH - iH * scale) / 2;
        updateTransform();
    }
    function zoomIn() { scale *= 1.2; updateTransform(); }
    function zoomOut() { scale /= 1.2; updateTransform(); }
    
    viewport.addEventListener('wheel', (e) => { e.preventDefault(); if (e.deltaY < 0) scale *= 1.1; else scale /= 1.1; updateTransform(); });
    
    function toggleDrawMode() {
        isDrawingMode = !isDrawingMode;
        const btn = document.getElementById('drawBtn');
        if (isDrawingMode) {
            btn.classList.add('mode-active');
            btn.innerText = "âŒ çµæŸç•«æ¡†";
            viewport.classList.add('crosshair');
            modeIndicator.innerText = "æ¨¡å¼ï¼šè«‹åœ¨ç•«é¢ä¸Šæ‹–æ›³æ‹‰æ¡†";
            modeIndicator.style.color = "#ff3d00";
            log("ğŸ–ï¸ è«‹æŒ‰ä½æ»‘é¼ å·¦éµç•«æ¡†");
        } else {
            btn.classList.remove('mode-active');
            btn.innerText = "ğŸ–ï¸ æ‰‹å‹•ç•«æ¡†";
            viewport.classList.remove('crosshair');
            modeIndicator.innerText = "æ¨¡å¼ï¼šæ»¾è¼ªç¸®æ”¾ / æ‹–æ›³èƒŒæ™¯ç§»å‹•";
            modeIndicator.style.color = "#aaa";
            tempSelectionBox.style.display = 'none';
        }
    }

    viewport.addEventListener('mousedown', (e) => {
        if (isDrawingMode && !e.target.classList.contains('corner-point')) {
            isDrawing = true;
            const rect = imgWrap.getBoundingClientRect();
            drawStartX = (e.clientX - rect.left) / scale;
            drawStartY = (e.clientY - rect.top) / scale;
            tempSelectionBox.style.left = drawStartX + 'px';
            tempSelectionBox.style.top = drawStartY + 'px';
            tempSelectionBox.style.width = '0px';
            tempSelectionBox.style.height = '0px';
            tempSelectionBox.style.display = 'block';
            e.stopPropagation();
            return;
        }
        if (!e.target.classList.contains('corner-point')) {
            isPanning = true; startPanX = e.clientX - panX; startPanY = e.clientY - panY; viewport.classList.add('grabbing');
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isDrawingMode && isDrawing) {
            const rect = imgWrap.getBoundingClientRect();
            let currX = (e.clientX - rect.left) / scale;
            let currY = (e.clientY - rect.top) / scale;
            let x = Math.min(drawStartX, currX); let y = Math.min(drawStartY, currY);
            let w = Math.abs(currX - drawStartX); let h = Math.abs(currY - drawStartY);
            x = Math.max(0, x); y = Math.max(0, y);
            w = Math.min(w, imgElement.width - x); h = Math.min(h, imgElement.height - y);
            tempSelectionBox.style.left = x + 'px'; tempSelectionBox.style.top = y + 'px';
            tempSelectionBox.style.width = w + 'px'; tempSelectionBox.style.height = h + 'px';
            return;
        }
        if (isPanning) { e.preventDefault(); panX = e.clientX - startPanX; panY = e.clientY - startPanY; updateTransform(); }
    });

    window.addEventListener('mouseup', () => {
        if (isDrawingMode && isDrawing) {
            isDrawing = false;
            const w = parseFloat(tempSelectionBox.style.width); const h = parseFloat(tempSelectionBox.style.height);
            const x = parseFloat(tempSelectionBox.style.left); const y = parseFloat(tempSelectionBox.style.top);
            if (w > 20 && h > 20) {
                currentCorners = { tl: {x:x, y:y}, tr: {x:x+w, y:y}, br: {x:x+w, y:y+h}, bl: {x:x, y:y+h} };
                updateManualPointsUI(); highlightPolygon.style.opacity = '1'; toggleDrawMode(); applyManualCrop(true);
            }
            tempSelectionBox.style.display = 'none';
        }
        isPanning = false; viewport.classList.remove('grabbing');
    });

    function toggleMaskOverlay() {
        maskOverlay.style.display = document.getElementById('showMaskToggle').checked ? 'block' : 'none';
    }

    async function autoDetect() {
        if (!isCvLoaded) return;
        if(isDrawingMode) toggleDrawMode();

        log("ğŸ§  AI åˆ†æä¸­...");
        document.getElementById('autoBtn').disabled = true;

        setTimeout(async () => {
            try {
                let srcMat;
                if (window.runAIRemoval) {
                    try {
                        const dataUrl = canvasInput.toDataURL("image/png");
                        const aiCanvas = await window.runAIRemoval(dataUrl, canvasInput.width, canvasInput.height);
                        
                        ctxOverlay.clearRect(0, 0, maskOverlay.width, maskOverlay.height);
                        ctxOverlay.globalAlpha = 0.5;
                        ctxOverlay.drawImage(aiCanvas, 0, 0);
                        const oData = ctxOverlay.getImageData(0, 0, maskOverlay.width, maskOverlay.height);
                        for(let i=0; i<oData.data.length; i+=4) {
                            if(oData.data[i] > 100) { 
                                oData.data[i] = 255; oData.data[i+1] = 0; oData.data[i+2] = 0; oData.data[i+3] = 128;
                            } else {
                                oData.data[i+3] = 0;
                            }
                        }
                        ctxOverlay.putImageData(oData, 0, 0);
                        
                        srcMat = cv.imread(aiCanvas);
                        log("ğŸ¤– AI åµæ¸¬å®Œæˆ (ç´…è‰²å€åŸŸ)", "info");
                    } catch (e) {
                        console.error(e);
                        log("âŒ AI å¤±æ•—/è¶…æ™‚ï¼Œè½‰å‚³çµ±æ¨¡å¼", "error");
                        srcMat = cv.imread(canvasInput);
                    }
                }

                let gray = new cv.Mat(), debugMat = new cv.Mat();
                cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.threshold(gray, debugMat, 20, 255, cv.THRESH_BINARY);

                let contours = new cv.MatVector();
                cv.findContours(debugMat, contours, new cv.Mat(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                let maxArea = 0, bestCnt = null;
                const minArea = (srcMat.cols * srcMat.rows) * 0.01;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > maxArea && area > minArea) {
                        maxArea = area;
                        bestCnt = cnt;
                    }
                }

                if (bestCnt) {
                    let rect = cv.minAreaRect(bestCnt);
                    let w = rect.size.width; let h = rect.size.height;
                    let ratio = Math.max(w,h) / Math.min(w,h);
                    
                    let vertices = cv.RotatedRect.points(rect);
                    let ptsSource = [];
                    for(let i=0; i<4; i++) ptsSource.push(vertices[i]);
                    ptsSource.sort((a,b) => a.y - b.y);
                    let top = ptsSource.slice(0,2).sort((a,b) => a.x - b.x);
                    let bottom = ptsSource.slice(2,4).sort((a,b) => a.x - b.x);

                    if (ratio < 1.4) {
                        log("âš ï¸ åµæ¸¬åˆ°å€’å½±ï¼Œè‡ªå‹•æ ¡æ­£", "warning");
                        let cutRatio = 0.3;
                        bottom[0].y -= (bottom[0].y - top[0].y) * cutRatio;
                        bottom[1].y -= (bottom[1].y - top[1].y) * cutRatio;
                    } else {
                        log("âœ… åµæ¸¬æˆåŠŸ", "success");
                    }
                    
                    currentCorners = { tl: top[0], tr: top[1], br: bottom[1], bl: bottom[0] };
                    highlightPolygon.style.opacity = '1';
                    applyManualCrop(true);
                } else {
                    log("âš ï¸ æœªåµæ¸¬åˆ°ç‰©é«”", "warning");
                }

                updateManualPointsUI();
                srcMat.delete(); gray.delete(); debugMat.delete(); contours.delete();
                document.getElementById('autoBtn').disabled = false;

            } catch (err) { 
                console.error(err); 
                log("âŒ éŒ¯èª¤: " + err, "error"); 
                document.getElementById('autoBtn').disabled = false;
            }
        }, 50);
    }

    cornerPoints.forEach(point => { point.addEventListener('mousedown', (e) => { if(isDrawingMode) return; activePoint = e.target; e.stopPropagation(); }); });
    window.addEventListener('mousemove', (e) => { if (!activePoint) return; const rect = imgWrap.getBoundingClientRect(); let x = (e.clientX - rect.left) / scale; let y = (e.clientY - rect.top) / scale; currentCorners[activePoint.id.split('-')[1]] = { x, y }; updateManualPointsUI(); });
    window.addEventListener('mouseup', () => { activePoint = null; });

    function resetCorners() { const w = imgElement.width; const h = imgElement.height; const pad = 50; currentCorners = { tl: {x: pad, y: pad}, tr: {x: w-pad, y: pad}, br: {x: w-pad, y: h-pad}, bl: {x: pad, y: h-pad} }; updateManualPointsUI(); }
    function updateManualPointsUI() { setPointCss('cp-tl', currentCorners.tl); setPointCss('cp-tr', currentCorners.tr); setPointCss('cp-br', currentCorners.br); setPointCss('cp-bl', currentCorners.bl); updateHighlightPolygon(); }
    function setPointCss(id, pt) { const el = document.getElementById(id); el.style.left = pt.x + 'px'; el.style.top = pt.y + 'px'; }
    function updateHighlightPolygon() { const points = [currentCorners.tl, currentCorners.tr, currentCorners.br, currentCorners.bl]; polyShape.setAttribute('points', points.map(p => `${p.x},${p.y}`).join(' ')); }

    function applyManualCrop(isAuto = false) {
        if (!isCvLoaded) return;
        if (!isAuto) log("âœ‚ï¸ è£åˆ‡ä¸­...");
        setTimeout(() => {
            try {
                let src = cv.imread(canvasInput);
                let dst = new cv.Mat();
                let tl = currentCorners.tl, tr = currentCorners.tr, br = currentCorners.br, bl = currentCorners.bl;
                let width = Math.max(Math.hypot(br.x-bl.x, br.y-bl.y), Math.hypot(tr.x-tl.x, tr.y-tl.y));
                let height = Math.max(Math.hypot(tr.x-br.x, tr.y-br.y), Math.hypot(tl.x-bl.x, tl.y-bl.y));
                let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                cv.warpPerspective(src, dst, M, new cv.Size(width, height));
                cv.imshow('canvasOutput', dst);
                document.getElementById('dlBtn').disabled = false;
                if(!isAuto) log("âœ… è£åˆ‡å®Œæˆ");
                src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
            } catch (err) { console.error(err); }
        }, 50);
    }

    function downloadResult() { let link = document.createElement('a'); link.download = 'ID_Cropped.png'; link.href = canvasOutput.toDataURL('image/png'); link.click(); }
</script>
</body>
</html>
