<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V14 ID Master (Axis-Locked Controls)</title>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvScriptLoad()" type="text/javascript"></script>
    <style>
        /* --- åŸºç¤æ¨£å¼ --- */
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #181818; color: #e0e0e0; margin: 0; padding: 20px; height: 100vh; box-sizing: border-box; overflow: hidden; }
        h2 { color: #fff; margin: 0 0 5px 0; font-size: 1.5rem; }
        .subtitle { color: #888; font-size: 0.9em; margin-bottom: 15px; }
        
        button { background: #333; color: white; border: 1px solid #555; padding: 10px 15px; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s; user-select: none; font-weight: 500; }
        button:hover:not(:disabled) { background: #444; border-color: #777; }
        button:active:not(:disabled) { transform: translateY(1px); }
        
        /* AI æŒ‰éˆ• */
        button.ai-primary { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            border: none; color: white; font-weight: bold; 
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
        }
        button.ai-primary:hover:not(:disabled) { 
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%); 
            box-shadow: 0 6px 20px rgba(118, 75, 162, 0.6); transform: translateY(-1px);
        }
        
        button.success { background: #28a745; border-color: #28a745; font-weight: bold;}
        button.success:hover:not(:disabled) { background: #218838; }
        button.warning { background: #ff9800; border-color: #f57c00; color: #000; font-weight: bold;} 
        button.warning:hover:not(:disabled) { background: #fb8c00; }
        button.info { background: #17a2b8; border-color: #17a2b8; font-weight: bold;}
        button.mode-active { background: #e91e63; border-color: #c2185b; color: white; box-shadow: 0 0 8px rgba(233, 30, 99, 0.6);}
        button:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(1); box-shadow: none; }

        #status { font-family: monospace; color: #aaa; margin-top: 10px; min-height: 1.2em; font-size: 0.85em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        
        .main-layout { display: flex; gap: 20px; height: calc(100% - 70px); align-items: flex-start; }
        
        .left-panel { 
            flex: 0 0 320px; background: #252525; padding: 20px; border-radius: 8px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px; 
            height: 100%; overflow-y: auto; box-sizing: border-box; border: 1px solid #333;
        }
        .step-box { border: 1px solid #444; padding: 15px; border-radius: 6px; background: #2a2a2a; transition: all 0.3s;}
        .step-box.active { border-color: #007bff; background: #2e353d; }
        .step-box.done { border-color: #28a745; opacity: 0.7; }
        .step-title { font-weight: bold; margin-bottom: 10px; display: block; color: #fff; font-size: 0.9rem; border-bottom: 1px solid #444; padding-bottom: 5px;}
        
        .upload-zone { 
            border: 2px dashed #555; padding: 25px 10px; text-align: center; border-radius: 6px; 
            cursor: pointer; transition: all 0.2s; background: rgba(255,255,255,0.02); color: #aaa; font-size: 0.9em;
            pointer-events: none; opacity: 0.5;
        }
        .upload-zone.ready { pointer-events: auto; opacity: 1; border-color: #007bff; color: #eee; }
        .upload-zone:hover { background: rgba(0,123,255,0.05); }

        .right-panel { flex: 1; display: flex; gap: 20px; height: 100%; min-width: 0; }
        .canvas-wrapper { 
            flex: 1; background: #1a1a1a; padding: 2px; border-radius: 4px; border: 1px solid #333;
            display: flex; flex-direction: column; position: relative; min-width: 0; overflow: hidden;
        }
        .canvas-header { 
            background: #252525; padding: 8px 12px; font-weight: bold; font-size: 0.85rem; 
            display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; z-index: 5;
        }
        
        .viewport {
            flex: 1; background: #111; overflow: hidden; position: relative; cursor: grab;
            background-image: radial-gradient(#222 1px, transparent 1px); background-size: 20px 20px;
        }
        .viewport.grabbing { cursor: grabbing; }
        .viewport.crosshair { cursor: crosshair; }

        #transformLayer { transform-origin: 0 0; position: absolute; top: 0; left: 0; will-change: transform; }
        .relative-img-wrap { position: relative; line-height: 0; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        canvas { display: block; }

        #manualAdjustLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; display: none; }
        
        #highlightPolygon {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5; opacity: 0; transition: opacity 0.3s;
        }
        #highlightPolygon polygon {
            fill: rgba(0, 229, 255, 0.1); stroke: rgba(0, 229, 255, 0.8); stroke-width: 2; vector-effect: non-scaling-stroke;
        }

        #tempSelectionBox {
            position: absolute; border: 1px dashed #ff0055; background: rgba(255, 0, 85, 0.1);
            pointer-events: none; display: none; z-index: 20;
        }

        /* --- è§’è½æ§åˆ¶é» (ç´…è‰²åœ“å½¢ - ä¿æŒä¸è®Š) --- */
        .corner-point {
            position: absolute; width: 14px; height: 14px; 
            background: rgba(255, 50, 50, 0.8); border: 2px solid #fff; border-radius: 50%;
            transform: translate(-50%, -50%); cursor: grab; pointer-events: auto; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 30; transition: background 0.1s;
        }
        .corner-point:hover { background: #ff0000; transform: translate(-50%, -50%) scale(1.2); border-color: yellow;}

        /* --- æ–°å¢ï¼šé‚Šç·£æ§åˆ¶æ¡¿ (ç™½è‰²é•·æ¢æ©¢åœ“) --- */
        .mid-point {
            position: absolute;
            background: #ffffff; /* æ”¹æˆç™½è‰² */
            border: 1px solid #888; /* è¼•å¾®é‚Šæ¡†å¢åŠ å°æ¯” */
            border-radius: 10px; /* æ©¢åœ“æ•ˆæœ */
            transform: translate(-50%, -50%); cursor: grab; pointer-events: auto;
            box-shadow: 0 2px 5px rgba(0,0,0,0.6); z-index: 29;
            /* â–¼â–¼â–¼ ä¿®æ”¹é€™è£¡ â–¼â–¼â–¼ */
            /* åŸæœ¬æ˜¯ all 0.1sï¼Œå°è‡´ä½ç½®ç§»å‹•ä¹Ÿæœ‰å»¶é²ã€‚æ”¹æˆåªå°èƒŒæ™¯å’Œé™°å½±åšå‹•ç•« */
            transition: background 0.1s, box-shadow 0.1s, border-color 0.1s; 
            /* â–²â–²â–² ä¿®æ”¹çµæŸ â–²â–²â–² */
        }
        /* ä¸Šä¸‹é‚Šç·£æ˜¯æ©«æ¢ */
        .mid-point[data-type="edge-top"], .mid-point[data-type="edge-bottom"] {
            width: 40px; height: 10px;
        }
        /* å·¦å³é‚Šç·£æ˜¯ç›´æ¢ */
        .mid-point[data-type="edge-left"], .mid-point[data-type="edge-right"] {
            width: 10px; height: 40px;
        }
        .mid-point:hover {
            background: #f0f0f0; /* hover ç¨å¾®è®Šç°ç™½ */
            border-color: #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.8);
            /* transform: translate(-50%, -50%) scale(1.1);  <-- ç§»é™¤ scaleï¼Œå› ç‚ºé•·æ¢ scale èµ·ä¾†æ€ªæ€ªçš„ï¼Œæ”¹ç”¨åŠ å¼·é™°å½± */
        }

        .zoom-controls { position: absolute; bottom: 15px; right: 15px; display: flex; gap: 5px; z-index: 50; }
        .zoom-btn {
            background: rgba(0,0,0,0.7); color: white; border: 1px solid #555; width: 30px; height: 30px;
            display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer; font-size: 16px;
        }
        .zoom-btn:hover { background: rgba(0,0,0,0.9); border-color: #888; }

        #canvasOutput { width: 100%; height: 100%; object-fit: contain; background: #000; }
        
        .btn-group { display: flex; gap: 8px; }
        .btn-group button { flex: 1; }
        
        #aiOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #6f42c1; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="aiOverlay">
    <div class="loader"></div>
    <div style="color:white; font-weight:bold; font-size:1.1em;">æ­£åœ¨å„ªåŒ–é‚Šç·£...</div>
    <div style="color:#aaa; font-size:0.9em; margin-top:5px;" id="aiProgress">AI é‹ç®—ä¸­</div>
</div>

<div style="text-align: center;">
    <h2>ğŸªª V14 ID Master</h2>
    <p class="subtitle">AI è‡ªå‹•å¤–æ“´ + è»¸å‘é–å®šæ§åˆ¶æ¡¿</p>
</div>

<div class="main-layout">
    <div class="left-panel">
        <div id="step1" class="step-box active">
            <span class="step-title">1. ä¸Šå‚³ç…§ç‰‡</span>
            <div id="systemLoading" style="text-align:center; color:#ffd700; margin-bottom:10px; font-size:0.85em;">
                â³ æ­£åœ¨åˆå§‹åŒ–å½±åƒå¼•æ“...
            </div>
            <input type="file" id="fileInput" accept="image/*" style="display:none">
            <div class="upload-zone" onclick="document.getElementById('fileInput').click()" id="uploadBox">
                <span id="uploadText">ğŸ“· è«‹ç¨å€™...</span>
            </div>
        </div>

        <div id="step2" class="step-box" style="pointer-events: none; opacity: 0.5; flex: 1; display:flex; flex-direction:column;">
            <span class="step-title">2. ç·¨è¼¯èˆ‡è¼¸å‡º</span>
            <div style="display: flex; flex-direction: column; gap: 12px;">
                
                <div class="btn-group">
                    <button onclick="rotateSource(-90)" class="info" title="å‘å·¦æ—‹è½‰">â†º å·¦è½‰</button>
                    <button onclick="rotateSource(90)" class="info" title="å‘å³æ—‹è½‰">â†» å³è½‰</button>
                </div>

                <button onclick="runAiDetection()" id="aiBtn" class="ai-primary" disabled style="padding: 15px; font-size:1.1em;">
                    âš¡ AI è‡ªå‹•åµæ¸¬
                </button>

                <div class="btn-group">
                    <button onclick="toggleDrawMode()" id="drawBtn" class="warning" disabled>ğŸ–ï¸ æ‰‹å‹•ç•«æ¡†</button>
                    <button onclick="resetView()" class="zoom-reset" style="font-size: 12px;">ğŸ” é‡ç½®è¦–è§’</button>
                </div>

                <div id="manualControls" style="display:block; border-top: 1px solid #444; padding-top: 10px;">
                    <p id="guideText" style="font-size:0.85em; color:#ddd; margin: 0 0 8px;">ğŸ‘‡ æ‹–æ›³ <span style="color:#ff5050">ç´…é»(è§’)</span> æˆ– <span style="color:#ffffff; background:#555; padding: 0 4px; border-radius:4px;">ç™½æ¡¿(é‚Š)</span> å¾®èª¿ï¼š</p>
                    <button onclick="applyManualCrop()" id="applyBtn" class="success" style="width:100%">âœ… æ‡‰ç”¨è£åˆ‡</button>
                </div>
                
                <div style="margin-top: auto;">
                    <button onclick="downloadResult()" id="dlBtn" disabled style="width:100%">ğŸ“¥ ä¸‹è¼‰çµæœ</button>
                </div>
            </div>
            <div id="status"></div>
            <label style="margin-top:10px; font-size:0.8em; color:#666;">
                <input type="checkbox" id="showDebug"> é¡¯ç¤º Debug
            </label>
        </div>
    </div>

    <div class="right-panel">
        <div class="canvas-wrapper">
            <div class="canvas-header">
                <span>ğŸ“ åŸå§‹å½±åƒ (HD)</span>
                <small id="modeIndicator" style="color:#aaa;">æ»¾è¼ªç¸®æ”¾ / æ‹–æ›³èƒŒæ™¯ç§»å‹•</small>
            </div>
            
            <div class="viewport" id="viewport">
                <div id="transformLayer">
                    <div class="relative-img-wrap" id="imgWrap">
                        <canvas id="canvasInput"></canvas>
                        
                        <svg id="highlightPolygon">
                            <polygon points=""></polygon>
                        </svg>
                        <div id="tempSelectionBox"></div>
                        <div id="manualAdjustLayer">
                            <div class="corner-point" id="cp-tl" data-type="corner"></div>
                            <div class="corner-point" id="cp-tr" data-type="corner"></div>
                            <div class="corner-point" id="cp-br" data-type="corner"></div>
                            <div class="corner-point" id="cp-bl" data-type="corner"></div>

                            <div class="mid-point" id="mp-top" data-type="edge-top" title="æ‹–æ›³èª¿æ•´ä¸Šé‚Šç·£"></div>
                            <div class="mid-point" id="mp-right" data-type="edge-right" title="æ‹–æ›³èª¿æ•´å³é‚Šç·£"></div>
                            <div class="mid-point" id="mp-bottom" data-type="edge-bottom" title="æ‹–æ›³èª¿æ•´ä¸‹é‚Šç·£"></div>
                            <div class="mid-point" id="mp-left" data-type="edge-left" title="æ‹–æ›³èª¿æ•´å·¦é‚Šç·£"></div>
                        </div>
                    </div>
                </div>
                
                <div class="zoom-controls">
                    <div class="zoom-btn" onclick="zoomIn()">+</div>
                    <div class="zoom-btn" onclick="zoomOut()">-</div>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper" style="flex: 0 0 35%;">
            <div class="canvas-header">âœ‚ï¸ è£åˆ‡çµæœ</div>
            <div style="flex:1; background:#000; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                <canvas id="canvasOutput"></canvas>
            </div>
        </div>
    </div>
</div>

<canvas id="canvasDebug" style="display:none; position:fixed; bottom:0; right:0; width:300px; border:2px solid yellow; z-index:999; background:black;"></canvas>

<script type="module">
    import { removeBackground } from 'https://cdn.jsdelivr.net/npm/@imgly/background-removal/+esm';
    window.removeBackground = removeBackground;
    console.log("Imgly loaded");
</script>

<script>
    // --- è®Šæ•¸ ---
    let imgElement = new Image();
    let isCvLoaded = false;
    let currentCorners = { tl: {x:0,y:0}, tr: {x:0,y:0}, br: {x:0,y:0}, bl: {x:0,y:0} };
    
    let scale = 1; let panX = 0, panY = 0; let isPanning = false; let startPanX = 0, startPanY = 0;
    let isDrawingMode = false; let isDrawing = false; let drawStartX = 0, drawStartY = 0;
    
    // æ‹–æ›³ç‹€æ…‹
    let activeHandle = null; 
    let activeHandleType = null;
    let dragStartMouse = {x:0, y:0};
    
    // DOM
    const viewport = document.getElementById('viewport');
    const transformLayer = document.getElementById('transformLayer');
    const canvasInput = document.getElementById('canvasInput');
    const canvasOutput = document.getElementById('canvasOutput');
    const ctxInput = canvasInput.getContext('2d');
    const highlightPolygon = document.getElementById('highlightPolygon');
    const polyShape = highlightPolygon.querySelector('polygon');
    const manualAdjustLayer = document.getElementById('manualAdjustLayer');
    const imgWrap = document.getElementById('imgWrap');
    const tempSelectionBox = document.getElementById('tempSelectionBox');
    const statusText = document.getElementById('status');
    const modeIndicator = document.getElementById('modeIndicator');
    const uploadBox = document.getElementById('uploadBox');
    const aiOverlay = document.getElementById('aiOverlay');
    const aiProgress = document.getElementById('aiProgress');
    let hiddenAiCanvas = document.createElement('canvas');

    function log(msg, type='') {
        statusText.innerText = msg;
        statusText.style.color = type === 'error' ? '#ff5252' : (type === 'warning' ? '#ffc107' : '#aaa');
    }

    // åˆå§‹åŒ–
    function onOpenCvScriptLoad() {
        let checkInterval = setInterval(() => {
            if (typeof cv !== 'undefined' && cv.Mat) {
                clearInterval(checkInterval);
                isCvLoaded = true;
                document.getElementById('systemLoading').innerText = "âœ… å½±åƒå¼•æ“å°±ç·’";
                document.getElementById('systemLoading').style.color = "#4caf50";
                uploadBox.classList.add('ready');
                document.getElementById('uploadText').innerText = "ğŸ“· é»æ“Šä¸Šå‚³ / æ‹–æ›³åœ–ç‰‡";
            }
        }, 200);
    }

    document.getElementById('fileInput').addEventListener('change', (e) => handleFile(e.target.files[0]));
    uploadBox.addEventListener('dragover', (e) => { e.preventDefault(); if(isCvLoaded) uploadBox.style.borderColor = '#007bff'; });
    uploadBox.addEventListener('dragleave', (e) => { e.preventDefault(); if(isCvLoaded) uploadBox.style.borderColor = '#555'; });
    uploadBox.addEventListener('drop', (e) => { e.preventDefault(); if(!isCvLoaded) return; uploadBox.style.borderColor = '#555'; handleFile(e.dataTransfer.files[0]); });

    function handleFile(file) {
        if(!file) return;
        let url = URL.createObjectURL(file);
        imgElement.src = url;
        imgElement.onload = function() {
            refreshCanvasInput(); 
            resetCorners();
            highlightPolygon.style.opacity = '0'; 
            manualAdjustLayer.style.display = 'none';
            document.getElementById('step1').classList.remove('active'); document.getElementById('step1').classList.add('done');
            activateStep(document.getElementById('step2'));
            document.getElementById('drawBtn').disabled = false;
            document.getElementById('aiBtn').disabled = false;
            resetView(); 
            log("ğŸ“· è¼‰å…¥å®Œæˆ");
        }
    }

    function activateStep(el) { el.style.pointerEvents = "auto"; el.style.opacity = "1"; el.classList.add('active'); }
    function refreshCanvasInput() {
        canvasInput.width = imgElement.width;
        canvasInput.height = imgElement.height;
        ctxInput.drawImage(imgElement, 0, 0);
    }

    // --- AI æ ¸å¿ƒ ---
    async function runAiDetection() {
        if (!window.removeBackground) { alert("AI æ¨¡çµ„å°šæœªè¼‰å…¥"); return; }
        if (isDrawingMode) toggleDrawMode();

        aiOverlay.style.display = 'flex';
        aiProgress.innerText = "Step 1: AI åˆ†æé‚Šç·£...";

        try {
            const blob = await window.removeBackground(imgElement.src, {
                progress: (key, current, total) => {
                    const pct = Math.round((current/total)*100);
                    aiProgress.innerText = `ä¸‹è¼‰ AI æ¨¡å‹... ${pct}%`;
                }
            });

            aiProgress.innerText = "Step 2: å„ªåŒ–åº§æ¨™èˆ‡è‡ªå‹•å¤–æ“´...";
            
            const tempImg = new Image();
            tempImg.src = URL.createObjectURL(blob);
            await new Promise((resolve) => { tempImg.onload = resolve; });

            hiddenAiCanvas.width = imgElement.width;
            hiddenAiCanvas.height = imgElement.height;
            const ctxAi = hiddenAiCanvas.getContext('2d');
            ctxAi.fillStyle = "black";
            ctxAi.fillRect(0, 0, hiddenAiCanvas.width, hiddenAiCanvas.height);
            ctxAi.drawImage(tempImg, 0, 0, hiddenAiCanvas.width, hiddenAiCanvas.height);

            // Debug ç¹ªåœ– (ä¿®å¾©)
            const debugCanvas = document.getElementById('canvasDebug');
            debugCanvas.width = 300; 
            debugCanvas.height = 300 * (imgElement.height / imgElement.width);
            debugCanvas.getContext('2d').drawImage(hiddenAiCanvas, 0, 0, debugCanvas.width, debugCanvas.height);
            
            let targetCoords = calculateCorners(hiddenAiCanvas);
            
            aiOverlay.style.display = 'none';

            if (targetCoords) {
                // è‡ªå‹•å¤–æ“´ 2%
                targetCoords = inflateRegion(targetCoords, 1.02); 
                log("âœ¨ åµæ¸¬æˆåŠŸ (å·²è‡ªå‹•è£œå„Ÿåœ“è§’)", "success");
                highlightPolygon.style.opacity = '1';
                manualAdjustLayer.style.display = 'block';
                animateToCorners(targetCoords);
            } else {
                log("âš ï¸ åµæ¸¬å¤±æ•—ï¼Œè«‹å˜—è©¦æ‰‹å‹•", "warning");
            }

        } catch (error) {
            console.error(error);
            aiOverlay.style.display = 'none';
            alert("éŒ¯èª¤: " + error);
        }
    }

    // è‡ªå‹•å¤–æ“´
    function inflateRegion(coords, factor) {
        const centerX = (coords.tl.x + coords.tr.x + coords.br.x + coords.bl.x) / 4;
        const centerY = (coords.tl.y + coords.tr.y + coords.br.y + coords.bl.y) / 4;
        function expandPoint(pt) { return { x: centerX + (pt.x - centerX) * factor, y: centerY + (pt.y - centerY) * factor }; }
        const w = imgElement.width; const h = imgElement.height;
        const clamp = (val, max) => Math.max(0, Math.min(val, max));
        let newTl = expandPoint(coords.tl); let newTr = expandPoint(coords.tr);
        let newBr = expandPoint(coords.br); let newBl = expandPoint(coords.bl);
        return { tl: { x: clamp(newTl.x, w), y: clamp(newTl.y, h) }, tr: { x: clamp(newTr.x, w), y: clamp(newTr.y, h) }, br: { x: clamp(newBr.x, w), y: clamp(newBr.y, h) }, bl: { x: clamp(newBl.x, w), y: clamp(newBl.y, h) } };
    }

    function calculateCorners(sourceCanvas) {
        try {
            let src = cv.imread(sourceCanvas);
            let gray = new cv.Mat(), debugMat = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(gray, debugMat, 10, 255, cv.THRESH_BINARY);
            let contours = new cv.MatVector();
            cv.findContours(debugMat, contours, new cv.Mat(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            let maxArea = 0, bestApprox = null;
            const minArea = (src.cols * src.rows) * 0.05;
            for (let i = 0; i < contours.size(); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                if (area > minArea) {
                    let peri = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.01 * peri, true);
                    if (approx.rows >= 4 && approx.rows <= 8 && area > maxArea && cv.isContourConvex(approx)) {
                        maxArea = area; if(bestApprox) bestApprox.delete(); bestApprox = approx;
                    } else { approx.delete(); }
                }
            }
            let result = null;
            if (bestApprox) {
                let rect = cv.minAreaRect(bestApprox);
                let vertices = cv.RotatedRect.points(rect);
                let pts = []; for(let i=0; i<4; i++) pts.push(vertices[i]);
                pts.sort((a,b) => a.y - b.y);
                let top = pts.slice(0,2).sort((a,b) => a.x - b.x);
                let bottom = pts.slice(2,4).sort((a,b) => a.x - b.x);
                result = { tl: top[0], tr: top[1], br: bottom[1], bl: bottom[0] };
                bestApprox.delete();
            }
            src.delete(); gray.delete(); debugMat.delete(); contours.delete();
            return result;
        } catch (err) { console.error(err); return null; }
    }

    function animateToCorners(target, duration = 600) {
        const start = JSON.parse(JSON.stringify(currentCorners));
        const startTime = performance.now();
        function step(currentTime) {
            const elapsed = currentTime - startTime;
            let progress = Math.min(elapsed / duration, 1);
            const ease = 1 - Math.pow(1 - progress, 3);
            ['tl', 'tr', 'br', 'bl'].forEach(key => {
                currentCorners[key].x = start[key].x + (target[key].x - start[key].x) * ease;
                currentCorners[key].y = start[key].y + (target[key].y - start[key].y) * ease;
            });
            updateManualPointsUI();
            if (progress < 1) requestAnimationFrame(step); else applyManualCrop(true);
        }
        requestAnimationFrame(step);
    }

    // --- UI æ›´æ–° ---
    function updateManualPointsUI() {
        setPointCss('cp-tl', currentCorners.tl); setPointCss('cp-tr', currentCorners.tr);
        setPointCss('cp-br', currentCorners.br); setPointCss('cp-bl', currentCorners.bl);
        
        const mpTop = { x: (currentCorners.tl.x + currentCorners.tr.x)/2, y: (currentCorners.tl.y + currentCorners.tr.y)/2 };
        const mpRight = { x: (currentCorners.tr.x + currentCorners.br.x)/2, y: (currentCorners.tr.y + currentCorners.br.y)/2 };
        const mpBottom = { x: (currentCorners.br.x + currentCorners.bl.x)/2, y: (currentCorners.br.y + currentCorners.bl.y)/2 };
        const mpLeft = { x: (currentCorners.bl.x + currentCorners.tl.x)/2, y: (currentCorners.bl.y + currentCorners.tl.y)/2 };
        setPointCss('mp-top', mpTop); setPointCss('mp-right', mpRight);
        setPointCss('mp-bottom', mpBottom); setPointCss('mp-left', mpLeft);

        const pts = [currentCorners.tl, currentCorners.tr, currentCorners.br, currentCorners.bl];
        polyShape.setAttribute('points', pts.map(p => `${p.x},${p.y}`).join(' '));
    }
    function setPointCss(id, pt) { const el = document.getElementById(id); el.style.left = pt.x + 'px'; el.style.top = pt.y + 'px'; }
    function resetCorners() {
        const w = imgElement.width; const h = imgElement.height; const pad = 30;
        currentCorners = { tl: {x: pad, y: pad}, tr: {x: w-pad, y: pad}, br: {x: w-pad, y: h-pad}, bl: {x: pad, y: h-pad} };
        updateManualPointsUI();
    }

    // --- æ‹–æ›³é‚è¼¯ (å«è»¸å‘é–å®šä¿®æ­£) ---
    document.querySelectorAll('.corner-point, .mid-point').forEach(point => {
        point.addEventListener('mousedown', (e) => {
            if(isDrawingMode) return;
            activeHandle = e.target;
            activeHandleType = e.target.dataset.type;
            const rect = imgWrap.getBoundingClientRect();
            dragStartMouse = { x: (e.clientX - rect.left) / scale, y: (e.clientY - rect.top) / scale };
            e.stopPropagation();
        });
    });

    window.addEventListener('mousemove', (e) => {
        if (!activeHandle) return;
        const rect = imgWrap.getBoundingClientRect();
        let mouseX = (e.clientX - rect.left) / scale;
        let mouseY = (e.clientY - rect.top) / scale;
        mouseX = Math.max(0, Math.min(mouseX, imgElement.width));
        mouseY = Math.max(0, Math.min(mouseY, imgElement.height));

        if (activeHandleType === 'corner') {
            const key = activeHandle.id.split('-')[1];
            currentCorners[key] = { x: mouseX, y: mouseY };
        } 
        else {
            // --- é‚Šç·£æ‹–æ›³ (è»¸å‘é–å®š) ---
            // 1. å…ˆå–å¾—æ˜¯å“ªä¸€å€‹é‚Šç·£ (åŸæœ¬é€™è¡Œå¯«å¤ªä¸‹é¢äº†ï¼Œå°è‡´ä¸Šé¢è®€ä¸åˆ°)
            const edge = activeHandle.id.split('-')[1];

            // 2. è¨ˆç®—ç§»å‹•é‡
            const dx = mouseX - dragStartMouse.x;
            const dy = mouseY - dragStartMouse.y;
            
            // 3. æ›´æ–°æ»‘é¼ ä½ç½®ï¼Œä¾›ä¸‹ä¸€æ¬¡è¨ˆç®—ä½¿ç”¨
            dragStartMouse = { x: mouseX, y: mouseY };

            // 4. æ ¹æ“šæ–¹å‘ï¼Œåªæ›´æ–°éœ€è¦çš„è»¸å‘ (é€™æ¨£å°±å¯¦ç¾äº†é–å®š)
            if (edge === 'top') {
                currentCorners.tl.y += dy; 
                currentCorners.tr.y += dy;
            } else if (edge === 'bottom') {
                currentCorners.bl.y += dy; 
                currentCorners.br.y += dy;
            } else if (edge === 'left') {
                currentCorners.tl.x += dx; 
                currentCorners.bl.x += dx;
            } else if (edge === 'right') {
                currentCorners.tr.x += dx; 
                currentCorners.br.x += dx;
            }
        }
        updateManualPointsUI();
    });

    window.addEventListener('mouseup', () => { activeHandle = null; });


    // --- å…¶ä»–åŠŸèƒ½ (ä¿æŒä¸è®Š) ---
    function rotateSource(degrees) {
        if (!imgElement.src) return;
        const tempCanvas = document.createElement('canvas');
        const ctx = tempCanvas.getContext('2d');
        const w = imgElement.width; const h = imgElement.height;
        tempCanvas.width = h; tempCanvas.height = w;
        ctx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        ctx.rotate(degrees * Math.PI / 180);
        ctx.drawImage(imgElement, -w / 2, -h / 2);
        imgElement.src = tempCanvas.toDataURL();
    }
    function resetView() {
        const vW = viewport.clientWidth; const vH = viewport.clientHeight;
        const iW = imgElement.width || 800; const iH = imgElement.height || 600;
        const scaleW = (vW - 40) / iW; const scaleH = (vH - 40) / iH;
        scale = Math.min(scaleW, scaleH, 1); 
        panX = (vW - iW * scale) / 2; panY = (vH - iH * scale) / 2;
        updateTransform();
    }
    function updateTransform() { transformLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }
    function zoomIn() { scale *= 1.2; updateTransform(); }
    function zoomOut() { scale /= 1.2; updateTransform(); }
    
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault(); const oldScale = scale;
        if (e.deltaY < 0) scale *= 1.1; else scale /= 1.1;
        scale = Math.max(0.1, Math.min(scale, 10));
        const rect = viewport.getBoundingClientRect();
        const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
        panX = mouseX - (mouseX - panX) * (scale / oldScale);
        panY = mouseY - (mouseY - panY) * (scale / oldScale);
        updateTransform();
    });
    viewport.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('corner-point') || e.target.classList.contains('mid-point') || isDrawingMode) return;
        isPanning = true; startPanX = e.clientX - panX; startPanY = e.clientY - panY; viewport.classList.add('grabbing');
    });
    window.addEventListener('mousemove', (e) => {
        if (isPanning) { e.preventDefault(); panX = e.clientX - startPanX; panY = e.clientY - startPanY; updateTransform(); }
    });
    window.addEventListener('mouseup', () => { isPanning = false; viewport.classList.remove('grabbing'); });

    // Draw Mode
    function toggleDrawMode() {
        isDrawingMode = !isDrawingMode;
        const btn = document.getElementById('drawBtn');
        if (isDrawingMode) {
            btn.classList.add('mode-active'); btn.innerText = "âŒ çµæŸç•«æ¡†";
            viewport.classList.add('crosshair'); modeIndicator.innerText = "æ¨¡å¼ï¼šè«‹æ‹–æ›³ç•«å‡ºç¯„åœ";
            modeIndicator.style.color = "#e91e63"; 
        } else {
            btn.classList.remove('mode-active'); btn.innerText = "ğŸ–ï¸ æ‰‹å‹•ç•«æ¡†";
            viewport.classList.remove('crosshair'); modeIndicator.innerText = "æ¨¡å¼ï¼šæ»¾è¼ªç¸®æ”¾ / æ‹–æ›³èƒŒæ™¯ç§»å‹•";
            modeIndicator.style.color = "#aaa"; tempSelectionBox.style.display = 'none';
        }
    }
    viewport.addEventListener('mousedown', (e) => {
        if (!isDrawingMode || e.target.classList.contains('corner-point') || e.target.classList.contains('mid-point')) return;
        isDrawing = true; const rect = imgWrap.getBoundingClientRect();
        drawStartX = (e.clientX - rect.left) / scale; drawStartY = (e.clientY - rect.top) / scale;
        tempSelectionBox.style.left = drawStartX + 'px'; tempSelectionBox.style.top = drawStartY + 'px';
        tempSelectionBox.style.width = '0px'; tempSelectionBox.style.height = '0px';
        tempSelectionBox.style.display = 'block'; e.stopPropagation();
    });
    window.addEventListener('mousemove', (e) => {
        if (!isDrawingMode || !isDrawing) return;
        const rect = imgWrap.getBoundingClientRect();
        let currX = (e.clientX - rect.left) / scale; let currY = (e.clientY - rect.top) / scale;
        let x = Math.min(drawStartX, currX); let y = Math.min(drawStartY, currY);
        let w = Math.abs(currX - drawStartX); let h = Math.abs(currY - drawStartY);
        x = Math.max(0, x); y = Math.max(0, y); w = Math.min(w, imgElement.width - x); h = Math.min(h, imgElement.height - y);
        tempSelectionBox.style.left = x + 'px'; tempSelectionBox.style.top = y + 'px';
        tempSelectionBox.style.width = w + 'px'; tempSelectionBox.style.height = h + 'px';
    });
    window.addEventListener('mouseup', () => {
        if (!isDrawingMode || !isDrawing) return;
        isDrawing = false;
        const w = parseFloat(tempSelectionBox.style.width); const h = parseFloat(tempSelectionBox.style.height);
        const x = parseFloat(tempSelectionBox.style.left); const y = parseFloat(tempSelectionBox.style.top);
        if (w > 20 && h > 20) {
            currentCorners = { tl: {x: x, y: y}, tr: {x: x+w, y: y}, br: {x: x+w, y: y+h}, bl: {x: x, y: y+h} };
            updateManualPointsUI(); 
            highlightPolygon.style.opacity = '1'; 
            manualAdjustLayer.style.display = 'block';
            toggleDrawMode(); 
            applyManualCrop(true);
        }
        tempSelectionBox.style.display = 'none';
    });

    function applyManualCrop(isAuto = false) {
        if (!isCvLoaded) return;
        if (!isAuto) log("âœ‚ï¸ è£åˆ‡ä¸­...");
        setTimeout(() => {
            try {
                let src = cv.imread(canvasInput);
                let dst = new cv.Mat();
                let tl = currentCorners.tl, tr = currentCorners.tr, br = currentCorners.br, bl = currentCorners.bl;
                let width = Math.max(Math.hypot(br.x-bl.x, br.y-bl.y), Math.hypot(tr.x-tl.x, tr.y-tl.y));
                let height = Math.max(Math.hypot(tr.x-br.x, tr.y-br.y), Math.hypot(tl.x-bl.x, tl.y-bl.y));
                let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                cv.warpPerspective(src, dst, M, new cv.Size(width, height));
                cv.imshow('canvasOutput', dst);
                document.getElementById('dlBtn').disabled = false;
                if(!isAuto) log("âœ… è£åˆ‡å®Œæˆ");
                src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
            } catch (err) { console.error(err); }
        }, 20);
    }
    function downloadResult() {
        let link = document.createElement('a'); link.download = 'ID_Cropped_Final.png'; link.href = canvasOutput.toDataURL('image/png', 1.0); link.click();
    }
    document.getElementById('showDebug').addEventListener('change', (e) => {
        document.getElementById('canvasDebug').style.display = e.target.checked ? 'block' : 'none';
    });
</script>
</body>
</html>
